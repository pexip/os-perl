Backport of:

From 0c2990d652e985784f095bba4bc356481a66aa06 Mon Sep 17 00:00:00 2001
From: David Mitchell <davem@iabyn.com>
Date: Wed, 16 Oct 2013 13:59:12 +0100
Subject: [PATCH] [perl #119505] Segfault from bad backreference

The code that parses regex backrefs (or ambiguous backref/octal) such as
\123, did a simple atoi(), which could wrap round to negative values on
long digit strings and cause seg faults.

Include a check on the length of the digit string, and if greater than 9
digits, assume it can never be a valid backref (obviating the need for the
atoi() call).

I've also simplified the code a bit, putting most of the \g handling code
into a single block, rather than doing multiple "if (isg) {...}".
---
 regcomp.c     | 64 ++++++++++++++++++++++++++++++++++++++++++-----------------
 t/re/re_tests | 41 ++++++++++++++++++++++++++++++++++++++
 2 files changed, 87 insertions(+), 18 deletions(-)

Index: perl-5.14.2/regcomp.c
===================================================================
--- perl-5.14.2.orig/regcomp.c	2016-03-01 10:51:35.984873567 -0500
+++ perl-5.14.2/regcomp.c	2016-03-01 10:56:29.536041619 -0500
@@ -7854,6 +7854,21 @@
 }
 
 
+/* return atoi(p), unless it's too big to sensibly be a backref,
+ * in which case return I32_MAX (rather than possibly 32-bit wrapping) */
+
+static I32
+S_backref_value(char *p)
+{
+    char *q = p;
+
+    for (;isDIGIT(*q); q++); /* calculate length of num */
+    if (q - p == 0 || q - p > 9)
+        return I32_MAX;
+    return atoi(p);
+}
+
+
 /*
  - regatom - the lowest level
 
@@ -8324,10 +8339,11 @@
 	case '5': case '6': case '7': case '8': case '9':
 	    {
 		I32 num;
-		bool isg = *RExC_parse == 'g';
-		bool isrel = 0; 
 		bool hasbrace = 0;
-		if (isg) {
+
+		if (*RExC_parse == 'g') {
+		    bool isrel = 0;
+
 		    RExC_parse++;
 		    if (*RExC_parse == '{') {
 		        RExC_parse++;
@@ -8341,18 +8357,35 @@
 		        if (isrel) RExC_parse--;
                         RExC_parse -= 2;		            
 		        goto parse_named_seq;
-		}   }
-		num = atoi(RExC_parse);
-		if (isg && num == 0)
-		    vFAIL("Reference to invalid group 0");
-                if (isrel) {
-                    num = RExC_npar - num;
-                    if (num < 1)
-                        vFAIL("Reference to nonexistent or unclosed group");
+                    }
+
+                    num = S_backref_value(RExC_parse);
+                    if (num == 0)
+		        vFAIL("Reference to invalid group 0");
+                    else if (num == I32_MAX) {
+                        if (isDIGIT(*RExC_parse))
+			    vFAIL("Reference to nonexistent group");
+                        else
+                            vFAIL("Unterminated \\g... pattern");
+                    }
+
+                    if (isrel) {
+                        num = RExC_npar - num;
+                        if (num < 1)
+                            vFAIL("Reference to nonexistent or unclosed group");
+                    }
                 }
-		if (!isg && num > 9 && num >= RExC_npar)
-		    goto defchar;
-		else {
+                else {
+                    num = S_backref_value(RExC_parse);
+                    /* bare \NNN might be backref or octal */
+                    if (num == I32_MAX || (num > 9 && num >= RExC_npar))
+                        /* Probably a character specified in octal, e.g. \35 */
+                        goto defchar;
+                }
+
+                /* at this point RExC_parse definitely points to a backref
+                 * number */
+		{
 		    char * const parse_start = RExC_parse - 1; /* MJD */
 		    while (isDIGIT(*RExC_parse))
 			RExC_parse++;
@@ -8588,7 +8621,7 @@
 		    case '0': case '1': case '2': case '3':case '4':
 		    case '5': case '6': case '7': case '8':case '9':
 			if (*p == '0' ||
-			    (isDIGIT(p[1]) && atoi(p) >= RExC_npar))
+			    (isDIGIT(p[1]) && S_backref_value(p) >= RExC_npar))
 			{
 			    I32 flags = PERL_SCAN_SILENT_ILLDIGIT;
 			    STRLEN numlen = 3;
Index: perl-5.14.2/t/re/re_tests
===================================================================
--- perl-5.14.2.orig/t/re/re_tests	2016-03-01 10:51:35.984873567 -0500
+++ perl-5.14.2/t/re/re_tests	2016-03-01 10:51:35.980873513 -0500
@@ -1471,6 +1471,47 @@
 [a\o{400}]	\x{100}	y	$&	\x{100}
 [a\o{1000}]	\x{200}	y	$&	\x{200}
 
+# avoid problems with 32-bit signed integer overflow
+
+(.)\g2147483648}	x	c	-	Reference to nonexistent group in regex
+(.)\g2147483649}	x	c	-	Reference to nonexistent group in regex
+(.)\g2147483650}	x	c	-	Reference to nonexistent group in regex
+(.)\g4294967296}	x	c	-	Reference to nonexistent group in regex
+(.)\g4294967297}	x	c	-	Reference to nonexistent group in regex
+(.)\g4294967298}	x	c	-	Reference to nonexistent group in regex
+a(.)\g2147483648}	x	c	-	Reference to nonexistent group in regex
+a(.)\g2147483649}	x	c	-	Reference to nonexistent group in regex
+a(.)\g2147483650}	x	c	-	Reference to nonexistent group in regex
+a(.)\g4294967296}	x	c	-	Reference to nonexistent group in regex
+a(.)\g4294967297}	x	c	-	Reference to nonexistent group in regex
+a(.)\g4294967298}	x	c	-	Reference to nonexistent group in regex
+
+(.)\g{2147483648}	x	c	-	Reference to nonexistent group in regex
+(.)\g{2147483649}	x	c	-	Reference to nonexistent group in regex
+(.)\g{2147483650}	x	c	-	Reference to nonexistent group in regex
+(.)\g{4294967296}	x	c	-	Reference to nonexistent group in regex
+(.)\g{4294967297}	x	c	-	Reference to nonexistent group in regex
+(.)\g{4294967298}	x	c	-	Reference to nonexistent group in regex
+a(.)\g{2147483648}	x	c	-	Reference to nonexistent group in regex
+a(.)\g{2147483649}	x	c	-	Reference to nonexistent group in regex
+a(.)\g{2147483650}	x	c	-	Reference to nonexistent group in regex
+a(.)\g{4294967296}	x	c	-	Reference to nonexistent group in regex
+a(.)\g{4294967297}	x	c	-	Reference to nonexistent group in regex
+a(.)\g{4294967298}	x	c	-	Reference to nonexistent group in regex
+
+(.)\2147483648	b\o{214}7483648	y	$1	b
+(.)\2147483649	b\o{214}7483649	y	$1	b
+(.)\2147483650	b\o{214}7483650	y	$1	b
+(.)\4294967296	b\o{42}94967296	y	$1	b
+(.)\4294967297	b\o{42}94967297	y	$1	b
+(.)\4294967298	b\o{42}94967298	y	$1	b
+a(.)\2147483648	ab\o{214}7483648	y	$1	b
+a(.)\2147483649	ab\o{214}7483649	y	$1	b
+a(.)\2147483650	ab\o{214}7483650	y	$1	b
+a(.)\4294967296	ab\o{42}94967296	y	$1	b
+a(.)\4294967297	ab\o{42}94967297	y	$1	b
+a(.)\4294967298	ab\o{42}94967298	y	$1	b
+
 # The below was inserting a NULL into the character class.
 [\8\9]	\000	n	-	-
 [\8\9]	8	y	$&	8
